# GEP-1911: Backend Protocol Selection

* Issue: [#1911](https://github.com/kubernetes-sigs/gateway-api/issues/1911)
* Status: Provisional

(See status definitions [here](overview.md#status).)

## TLDR

Not all implementation support automatic protocol selection. Even in some cases protocols are disabled without an explicit opt-in (ie. websockets). Thus application developers need the ability specify the protocol(s) that their application supports.

## Goals

- Support protocols that can have a Gateway '*Route' resource as a frontend
- Consistent way of declaring backend protocols using a meta-resource
- Support backends with multiple protocols on the same port (ie. h2c/http1)
- Extensible - additional protocol specific fields should be easy to add in the future

## Non-Goals

- Backend TLS (covered in [GEP-1897](https://github.com/kubernetes-sigs/gateway-api/issues/1897)

## Introduction

## API

We propose adding a new meta-resource [GEP-713](geps/gep-713.md):

### Go API

```go
type BackendProtocol struct {
  // Standard type metadata
  metav1.TypeMeta `json:",inline"`

  // Standard object's metadata
  metav1.ObjectMeta `json:"metadata,omitempty"`

  // Spec defines the behaviour of this meta-resource
  Spec BackendProtocolSpec `json:"spec,omitempty"`
}

type BackendProtocolSpec struct {
  // Specifies the API resource who's protocols are being
  // explicitly defined
  TargetRef LocalObjectReference `json:"targetRef"`

  // Ports contains a list of protocols for a specific ports
  // When multiple protocols reference the same port the 
  // entries earlier in the list should have higher priority
  //
  // ie. attempt to use h2c otherwise fallback on http1
  //  ports: 
  //   - port: 80
  //     http2: 
  //       encrypted: false # enable h2c
  //   - port: 80
  //     http1: {}          # We also listen to http1 on port 80
  //
  Ports []BackendPort `json:"ports,omitempty"`
}

type BackendPort struct {
  // Number or name of the port who's protocol is being defined
  Port intstr.IntOrString

  PortProtocol `json:",inline"`
}

type PortProtocol struct {
  HTTP2     *HTTP2PortProtocol    `json:"http2"`
  HTTP1     *HTTP1PortProtocol    `json:"http1"`
  GRPC      *GRPCPortProtocol     `json:"grpc"`
  WebSocket *WebsocketPortProtocol`json:"websocket"`
}

type HTTP2PortProtocol struct {
  Cleartext bool // h2c when set to true

  // Future knobs can go here
}

type HTTPPortProtocol struct {
  // Future knobs can go here
}
type GRPCPortProtocol struct {
  // Future knobs can go here
}
type WebsocketPortProtocol struct {
  // Future knobs can go here
}
```

### YAML API

```yaml
apiVersion: gateway.networking.k8s.io/v1alpha1
kind: BackendProtocol
metadata:
  name: some-service
  namespace: some-namespace
spec:
  ports:
  - port: 80
    http2: 
      encrypted: false # enable h2c
  - port: 80
    http1: {}          # We also listen to http1 on port 80
  - port: 9090
    grpc: {}
  - port: 8080
    websocket: {}      # enable websocket support on this port
  - port: 7070
    http1: {}
  targetRef:
    group: "" # corev1
    kind: Service
    name: some-service
```

### Default Protocols

If a backend protocol isn't specified an implementation MAY infer the backend protocol through it's own means.

### Incompatible Protocols

If a Route attached to a Gateway is not able to support sending traffic to the backend using a specific protocol 
then it must set it's condition to `Accepted` `False`.

## Alternatives

### Meta-resource for each protocol

Rather than bundle protocol details into a single resource an alternative would be to create distinct meta resources.
ie. `HTTP2Backend`, `GPRCBackend`, `WebsocketBackend`.

Although this has the advantage of seperate it doesn't allow

### Adding properties on Gateway Route Objects

From [GEP-1282](geps/gep-1282.md#tldr):
> some types of configuration requested by users are more about defining functionality that describes capabilities of the backend more than the route you take to get to the backend.

Backend protocol is specifying capabilities. This configuration is less about routing.

### Extending Kubernetes Service

This is considered untenable due to the 'the turnaround time for those changes can be years.' ([ref-1282](geps/gep-1282.md#non-goals):

### AppProtocol

From [GEP-1282](geps/gep-1282.md#non-goals):
> v1.Serviceâ€™s appProtocol field is not fit for purpose, because it is defined as accepting values either from the IANA Service Name registry, or domain-prefixed values and we need more flexibility than that. 

See further discussion [here](https://github.com/kubernetes-sigs/gateway-api/discussions/1244#discussioncomment-3151197)

An option would be to have a specific vendor prefix but unfortunately this limits the protocol to one per port.

### Unstructured Data/Special Values

Unstructured data refers to using labels and annotations.

From [GEP-1282](geps/gep-1282.md#non-goals):
> these are very sticky and hard to get rid of once you start using them.

Special values refers to using special strings in existing Kubernetes Resources.
For example Istio allows for protocol to be specified by prefixing the Kubernetes
Service's port name with the protocol (ie. `http-`, `grpc-`). This approach is
limiting as it doesn't allow for multiple protocols on the same port and future 
configuration per protocol. One protocol per port may be relaxed in the future see 
[KEP 1435](https://github.com/kubernetes/enhancements/tree/master/keps/sig-network/1435-mixed-protocol-lb)

## References

- GitHub Discussion - https://github.com/kubernetes-sigs/gateway-api/discussions/1244
- GEP-1282 - Describing Backend Properties
  - [GEP](geps/gep-1282.md)
  - [Issue](https://github.com/kubernetes-sigs/gateway-api/issues/1911)
- GEP-713 - Metaresources
  - [GEP](geps/gep-713.md)
- Linkerd Protocol Detection
  - https://linkerd.io/2.12/features/protocol-detection/
- Istio Protocol Selection 
  - https://istio.io/latest/docs/ops/configuration/traffic-management/protocol-selection/
- Contour Protocol Selection
  - Websockets - https://projectcontour.io/docs/1.24/config/websockets/
  - GRPC - https://projectcontour.io/docs/1.24/guides/grpc/#httpproxy-configuration
